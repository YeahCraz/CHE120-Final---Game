#DO: Please use two spaces to seperate functions and classes
#DO: also list variables for certain proerties seperately. Place variables at the beginning of the class if possible please
#DO: also comment your intials prior to commenting so we know who to ask if we have any question


import pygame #DO: Import the pygame library
from pygame.locals import * #DO: Import pygame local variables,
from sys import exit #DO: Import exit function from system (sys) module
from pygame.math import Vector2 #WB: For player and enemy movement 
import pytmx #DO: Import pytmx (makes maps)
import math #DO: importing math at the top is better notation and allows for it to be used globally
import random #FS: For potential randomization of projectile/character/enemy properties

class Projectile(pygame.sprite.Sprite): #FS: Projectile Class
    def __init__(self, x, y, velocity, angle, projectile_type, owner_id, damage_value): #FS: Class for initializing projectiles
        #DO: changed variables to float where precision would be useful
        super().__init__()
        self.x = float(x) #FS: x position of projectile
        self.y = float(y) #FS: y position of projectile
        self.velocity = float(velocity) #FS: Speed of the projectile
        self.angle = float(angle) #FS: Angle of bullet in radians, can be randomized/offset for styles
        self.projectile_type = projectile_type #FS: Will use projectile dictionary and touhou sprite sheet eventually
        self.owner_id = owner_id #FS: Projectile owner, will be used to make sure players/enemies don't hit themselves
        self.damage_value = float(damage_value) #FS: Damage value of the projectile
        # FS: Alright, for now instead of using the spritesheet (since idk how), Draw a simple circle for the projectile; color depends on type
        radius = 8
        if self.projectile_type == 'plasma': #FS: Added handling for ID of the projectile type. Nice!
            color = (255, 255, 0)  # yellow
        elif self.projectile_type == 'laser': 
            color = (50, 150, 255)  # blue
        else:
            color = (255, 255, 255)  # default white
        self.image = pygame.Surface((radius*2, radius*2), pygame.SRCALPHA)
        pygame.draw.circle(self.image, color, (radius, radius), radius) #FS: Currently makes a circle, can be changed.
        self.rect = self.image.get_rect(center=(x, y))

    def update(self, dt):
        import math
        dx = self.velocity * math.cos(self.angle) * dt #FS: velocity of projectile in x
        dy = self.velocity * math.sin(self.angle) * dt #FS: velocity of projectile in y
        #DO: correcting for rects given that i changed these to floats
        self.rect.x += int(dx)
        self.rect.y += int(dy)
    
    #FS: Projectile type dictionary
    projectile_dictionary = {
        "plasma": 1,
        "caliber": 2,
        "bean": 3,
        "star_sm": 4,
        "star_med": 5,
        "rice": 6,
        "seed": 7,
        "mentos": 8,
        "water": 9,
        "laser": 10
    }


class Player(pygame.sprite.Sprite): #DO: Define a player class
    def __init__(self,x,y): #DO: initialize the player class
        super().__init__() #DO: Required when inheriting from another class
        #DO: turn x and y into float if not already
        self.x = float(x)
        self.y = float(y)
        #DO: loading sprite sheet, it can viewed in "neo_zero_V1.0____Credit_YaninYunus"
        self.walk_sheet = pygame.image.load('Ronin\Ronin\spr_RoninRun_strip.png').convert_alpha() #DO: Load the sprite sheet image
        self.idle_sheet = pygame.image.load('Ronin\Ronin\spr_RoninIdle_strip.png').convert_alpha() #DO: Load the idle sprite sheet image

        #WB: Define player's health
        self.health = 100 #WB: Player starting health
        self.max_health = 100 #WB: Player's maximum health

        #DO: Define sprite dimensions
        self.sprite_width = 65 #DO: Define the width of a single sprite
        self.sprite_height = 65 #DO: Define the height of a single sprite
        self.speed = 300. #DO: Define player speed in pixels per second

        #DO: Define animation properties
        self.current_frame = 0 #DO: Current frame of animation, used in cycling through frames in animation
        self.animation_speed = .1 #DO: Speed of animation, controls the speed that said frames are cycled through
        self.animation_timer = 0. #DO: Timer to track animation progress, ensures that animation speed is consistent
        self.current_direction = 'right' #DO: Initial direction of the player
        self.moving = False #DO: Initialize moving variable to track if the player is moving
         #DO: get_rect() is a pygame method that returns a rectangle object that encloses the surface. The center parameter sets the center of the rectangle to the specified (x, y) coordinates.

        #DO: these are the parameters of the following function within the dictionary: load_frames(self, row, start_col, num_frames, flip_horizontal=False):
        #DO: when calling the function, we specify which row of the sprite sheet to use, which column to start from, and how many frames to load, and whether to flip the image horizontally. We dont need to assign self as the first argument is made automatically when calling a method with an object.
        self.walk_frames = { #DO: This is a dictionary, similar to a real dictonary. When we look up a word it has multiple meanings. We are then able to parse through these "meanings" to pick out the one we desire to use.
            'left': self.load_frames(self.walk_sheet,0,0,10,True,True), #DO: loads animation for walking left
            'right': self.load_frames(self.walk_sheet,0,0,10,False,True), #DO: loads animation for walking right
        }
        self.idle_frames = { #DO: This is a dictionary for idle frames
            'left': self.load_frames(self.idle_sheet,0,0,8,True,True), #DO: loads animation for idle left
            'right': self.load_frames(self.idle_sheet,0,0,8,False,True), #DO: loads animation for idle right
        }
        '''sprite sheets look like this:
        [Frame1] [Frame2] [Frame3] [Frame4]  
[Frame1] [Frame2] [Frame3] [Frame4]    
[Frame1] [Frame2] [Frame3] [Frame4]  
[Frame1] [Frame2] [Frame3] [Frame4]'''


        #DO: creates the image attribute for the sprite
        self.image = self.idle_frames[self.current_direction][self.current_frame] #DO: sets the initial image of the sprite to the first frame of the current direction's animation
        self.rect = self.image.get_rect(center = (x, y)) #DO: this provide a rectangle around the sprite for collision detection 
        

    def load_frames(self, sheet, row, start_col, num_frames, flip_horizontal=False, append_reverse = False): #DO: Function to load frames from the sprite sheet
        frames = [] #DO: Create an empty list to store the frames

        for i in range(num_frames): #DO: Loop through the number of frames to load
            frame = pygame.Surface((self.sprite_width, self.sprite_height), pygame.SRCALPHA) #DO: creates a surface the size of a single sprite with alpha transparency (i.e. the background is see through for the grid pattern in the sprite sheet)
            frame.blit(sheet, (0, 0), (start_col *self.sprite_width + i * self.sprite_width, row * self.sprite_height, self.sprite_width, self.sprite_height)) #DO: Draws(BLITS) the sprite sheet onto the frame surface  
            if flip_horizontal: #DO: If flip_horizontal is True
                frame = pygame.transform.flip(frame, True, False) #DO: Flip the surface(frame) horizontally (True) but not vertically (False)
            frames.append(frame) #DO: Add the frame to the frames list
            if append_reverse: #DO: If a sprite sheet lacks a complete animation it will loop back to the starting animation 
                frames += frames[::-1] #DO: Append the reversed frames excluding the last frame to create a smooth back-and-forth animation
        return frames #DO: Return the list of frames
    def movement(self, dt, collision_rects = None):
        keys = pygame.key.get_pressed() #DO: Get the state of all keyboard buttons


        self.moving = False #DO: Initialize moving variable to track if the player is moving
        new_direction = self.current_direction #DO: Initialize new_direction with the current direction
        if keys[K_LEFT] or keys[K_a]: #DO: Check for left movement keys
            new_direction = 'left'
            self.moving = True
        if keys[K_RIGHT] or keys[K_d]: #DO: Check for right movement keys
            new_direction = 'right'
            self.moving = True
        if keys[K_UP] or keys[K_w] or keys[K_DOWN] or keys[K_s]: #DO: Check for up or down movement keys. Up and down dont affect animation.
            self.moving = True
        
        
        #DO:changes direction if the player is moving, i.e. we begin moving in another direction
        if self.moving:
            self.current_direction = new_direction
        

        #DO: Actual movement logic 


        #DO: May have to change our left moving speed as it seems faster!!!!
        
                
        dx = 0.
        dy = 0.
        if keys[K_LEFT] or keys[K_a]: #DO: Check for left movement keys
            dx = -self.speed * dt
        if keys[K_RIGHT] or keys[K_d]: #DO: Check for right movement keys
            dx = self.speed * dt #FS: Currently, right movement is roughly this factor slower than left movement. Until I find the fix in the logic, we'll go with this.
        if keys[K_UP] or keys[K_w]: #DO: Check for up movement keys
            dy = -self.speed * dt
        if keys[K_DOWN] or keys[K_s]: #DO: Check for down movement keys
            dy = self.speed * dt #FS: The same issue persists with the down direction. I've applied the fix here as well.
        if keys[K_LSHIFT]: #FS: Check for movement with shift, for focus movement
            dx *= 0.75 #+ focus_factor #FS: Potentially, these factors can be altered with upgrades/options.
            dy *= 0.75 #+ focus_factor
            # FS: Seems to currently break downwards + right movement.
        #DO: recall that y is inverted in pygame, so moving up decreases y value, moving down increases y value
        #DO: also naturally given that direction is changed by +- self.speed * dt left and right would oppose each other and stop movement if both keys are pressed simultaneously
        #DO: to handle diagonals, we can change the speed of dx by a defined amount
        if dx != 0 and dy != 0: #DO: If both dx and dy are non-zero, we are moving diagonally
           dist = math.sqrt(dx*dx + dy*dy) #DO: takes the norm of the diagonal vector
           if dist > 0:
               dx = dx / dist * self.speed * dt #DO: dx / hypotenuse * speed * delta time
               dy = dy / dist * self.speed * dt
        #DO:"hitbox" created by rect attribute
        #DO: intifying from a float
        #DO: Wall Collision
        if collision_rects:
            #DO: check X direction
            if dx != 0:
                self.rect.x += int(dx) #DO: intify for rect
                for wall_rect in collision_rects: #DO: uses the returned list of collision_rects from the empty list
                    if self.rect.colliderect(wall_rect): #DO: checks for collisions between the self (player) and the argument (walls)
                        #DO: all collision logic sohuld have an if statement similar to that above
                        self.rect.x -= int(dx) #DO: counteracts the normal movement of the player upon wall collision
                        break
            if dy != 0:
                self.rect.y +=int(dy)
                for wall_rect in collision_rects:
                    if self.rect.colliderect(wall_rect):
                        self.rect.y -= int(dy)
                        break
        else:
            self.rect.x += int(dx) #DO: Update the player's x position in collision logic
            self.rect.y += int(dy) #DO: Update the player's y position in collision logic
        
        self.rect.x += int(dx) #DO: Update the player's x position in collision logic
        self.rect.y += int(dy) #DO: Update the player's y position in collision logic

    
    #DO: special collision handling for weapons, pickups, and enemies would go here

    
    #DO: handles animation based on movement
    def animation(self, dt): 
        if self.moving: #DO: If the player is moving run the walking animation
            self.animation_timer += dt #DO: Increment the animation timer by delta time
            if self.animation_timer >= self.animation_speed:
                self.animation_timer = 0 #DO: Reset the animation timer
                self.current_frame = (self.current_frame +1) % len(self.walk_frames[self.current_direction])
                self.image = self.walk_frames[self.current_direction][self.current_frame] #DO: Update the player's image to the current frame of the current direction's animation from the sprite sheet
        else: #DO: If the player is not moving, set to idle frame
            self.animation_timer += dt
            if self.animation_timer >= self.animation_speed:
                self.animation_timer = 0.
                self.current_frame = (self.current_frame + 1) % len(self.idle_frames[self.current_direction])
                self.image = self.idle_frames[self.current_direction][self.current_frame] #DO: Update the player's image to the second frame of the current direction's animation
    

    #DO: Update function to be called every frame
    def update(self, dt, collision_rects = None):
        self.movement(dt,collision_rects)
        self.animation(dt)

    #FS: Fire a projectile from the player
    def player_projectile(self, velocity, angle, projectile_type, damage_value):
        projectile = Projectile(self.rect.centerx, self.rect.centery, velocity, angle, projectile_type, id(self), damage_value)
        # FS: Add projectile to the same group as player (assumes all_sprites)
        for group in self.groups():
            group.add(projectile)
        return projectile
    
    #FS: TEST FUNCTION, IGNORE (USED FOR TESTING PROJECTILES FROM ANYWHERE)
    '''
    def projectile_anywhere(self, x, y, velocity, angle, projectile_type, damage_value):
        projectile = Projectile(x, y, velocity, angle, projectile_type, id(self), damage_value)
        for group in self.groups():
            group.add(projectile)
        return projectile
    '''
    #FS: END OF TEST FUNCTION, IGNORE

class Enemy(pygame.sprite.Sprite): #WB: Define the enemy class
    def __init__(self, x, y, enemy_type = "standard"): #WB: Initialize the enemy class

        super().__init__() #WB: Required when inherit from another class
        if enemy_type == "standard": #WB: Standard type of enemy, the most basic one in the game
            #WB: Define standard enemy's powers
            self.health = 40 #WB: Define standard enemy's health
            self.damage = 10 #WB: Define standard enemy's damage
            
            # WB: Create a simple placeholder image for testing
            self.image = pygame.Surface((50, 50)) #WB: Makes the enemy look like a square
            self.image.fill((255, 0, 0))  #WB: Makes the enemy look like a red square
            self.rect = self.image.get_rect(center=(x,y)) #WB: This provides a rectangle around the enemy for the collision detection
            
            #WB: Define standard enemy's dimensions
            self.sprite_width = 75 #WB: Define standard enemy's width 
            self.sprite_height = 75 #WB: Define standard enemy's height
            self.speed = 250 #WB: Define standard enemy's speed (faster than player)
            
            #WB: Defines animation properties
            self.current_frame = 0
            self.animation_speed = 0.01 #WB: Enemy animation slightly faster than player
            self.animation_timer = 0.0
            self.current_direction = 'right'  #WB: Based on player's position
            self.moving = False

        elif enemy_type == "moderate": #WB: Moderate type of enemy
            #WB: Define moderate enemy powers
            self.health = 60 #WB: Define moderate enemy's health
            self.damage = 30 #WB: Define moderate enemy's damage
            
             # WB: Create a simple placeholder image for testing
            self.image = pygame.Surface((50, 20)) #WB: Makes the enemy a rectangle
            self.image.fill((0, 255, 0))  #WB: Makes the enemy look like a green rectangle
            self.rect = self.image.get_rect(center=(x,y)) #WB: This provides a rectangle around the enemy for the collision detection
            
            #WB: Define moderate enemy's dimensions
            self.sprite_width = 50 #WB: Define moderate enemy's width 
            self.sprite_height = 60 #WB: Define moderate enemy's height
            self.speed = 220 #WB: Define moderate enemy's speed (slightly slower than player and than other enemy types)
            
            #WB: Defines animation properties
            self.current_frame = 0
            self.animation_speed = 0.15 #WB: Enemy animation slightly slower than player
            self.animation_timer = 0.0
            self.current_direction = 'right'  #WB: Based on player's position
            self.moving = False

        elif enemy_type == "strong": #WB: Strong type of enemy 
            #WB: Define strong enemy's powers
            self.health = 70 #WB: Define strong enemy's health
            self.damage = 35 #WB: Define strong enemy's damage 
            
            #WB: Define strong enemy's dimensions
            self.sprite_width = 80 #WB: Define the width of the strong enemy
            self.sprite_height = 80 #WB: Define the width of the strong enemy
            self.speed = 200 #WB: Define the speed of the strong enemy (slightly slower than player)
           
            # WB: Create a simple placeholder image for testing
            self.image = pygame.Surface((60, 60)) #WB: I'm going to change the image later but makes the enemy a square
            self.image.fill((0, 0, 255))  #WB: Makes the enemy look like a blue square
            self.rect = self.image.get_rect(center=(x,y)) #WB: This provides a rectangle around the enemy for the collision detection
            
            #WB: Defines animation properties
            self.current_frame = 0
            self.animation_speed = 0.1 
            self.animation_timer = 0.0
            self.current_direction = 'right'  #WB: Based on player's position
            self.moving = False

        elif enemy_type == "shooting": #WB: Shooting type of enemy 
            #WB: Define shooting enemy's powers
            self.health = 80 #WB: Define shooting enemy's health
            self.damage = 10 #WB: Define shooting enemy's damage 
            
            #WB: Define strong enemy's dimensions
            self.sprite_width = 20 #WB: Define the width of the shooting enemy
            self.sprite_height = 20 #WB: Define the width of the shooting enemy
            self.speed = 150 #WB: Define the speed of the shooting enemy (slower than player)
           
            # WB: Create a simple placeholder image for testing
            self.image = pygame.Surface((60, 60)) #WB: I'm going to change the image later but makes the enemy a square
            self.image.fill((255, 0, 255))  #WB: Makes the enemy look like a purple square
            self.rect = self.image.get_rect(center=(x,y)) #WB: This provides a rectangle around the enemy for the collision detection
            
            #WB: Defines animation properties
            self.current_frame = 0
            self.animation_speed = 0.1 
            self.animation_timer = 0.0
            self.current_direction = 'right'  #WB: Based on player's position
            self.moving = False
        
        #WB: ADD SPRITE SHEET LATER
        #WB: Parameters for functions within the dictionary (same as the player's): load_frames(self, row, start_col, num_frames, flip_horizontal=False):
        #DO: when calling the function, we specify which row of the sprite sheet to use, which column to start from, and how many frames to load, and whether to flip the image horizontally. We dont need to assign self as the first argument is made automatically when calling a method with an object.
        #self.walk_frames = {
        #"left": self.load_frames(walk_sheet, 0, 0, num_frames, True), #WB: Loads animation for walking left
        #"right": self.load_frames(walk_sheet, 0, 0, num_frames, False) #WB: Loads animation for walking right 
        #}
        #self.idle_frames = {
        #"left": self.load_frames(idle_sheet, 0, 0, num_frames, True), #WB: Loads animation for idle left
        #"right": self.load_frames(idle_sheet, 0, 0, num_frames, False) #WB: Loads animation for idle right
        #}

    def movement(self, player_rect, dt): #WB: Define enemy's movements
        player_position = Vector2(player_rect.center) #WB: Direction vector for the player
        enemy_position = Vector2(self.rect.center) #WB: Direction vector for the enemy
        direction = player_position - enemy_position #WB: Creates a direciton vector towards player
        distance = direction.length() #WB: Makes it that the enemy only moves if the player is within range

        if player_position.x < enemy_position.x: #WB: Makes the enemy's direction so that it always faces the player
            self.current_direction = "left"
        else:
            self.current_direction = "right"

        self.moving = (distance > 0)  #WB: Makes the enemy always move even when the player isn't moving
    
        if distance > 0:  #WB: The enemy will always chase the player as long as it is not on top of the player
            direction = direction.normalize()  #WB: Noramlizwe the direction to make the length equal to 1 so that the enemy's speed stays constant
            self.rect.x += direction.x * self.speed * dt #WB: Moves enemy left and right
            self.rect.y += direction.y * self.speed * dt #WB: Moves enemy down and up
        

            



    
    def enemy_animations (self, dt): #WB: Handles animations based on movement
    
    # WB: Simple shape animation for now FIX THIS AFTER PLEASE
        self.animation_timer += dt
    
        if self.animation_timer >= self.animation_speed:
            self.animation_timer = 0
            self.current_frame = (self.current_frame + 1) % 4
        
        # WB: Simple size pulse based on movement
        if self.moving:
            size = 50 + (self.current_frame * 3)  # 50, 53, 56, 53
        else:
            size = 48 + (self.current_frame * 1)  # 48, 49, 50, 49
        
        # WB: Keep the original color but change size
        if hasattr(self, 'image'):
            # Get current color from the image
            current_color = self.image.get_at((0, 0))
            self.image = pygame.Surface((int(size), int(size)))
            self.image.fill(current_color)

        #if self.moving: #DO: If the enemy is moving run the walking animation
            #self.animation_timer += dt #DO: Increment the animation timer by delta time
            #if self.animation_timer >= self.animation_speed:
                #self.animation_timer = 0 #DO: Reset the animation timer
                #self.current_frame = (self.current_frame +1) % len(self.walk_frames[self.current_direction])
                #self.image = self.walk_frames[self.current_direction][self.current_frame] #DO: Update the enemy's image to the current frame of the current direction's animation from the sprite sheet
        #else: #DO: If the player is not moving, set to idle frame
            #self.animation_timer += dt
            #if self.animation_timer >= self.animation_speed:
                #self.animation_timer = 0.
                #self.current_frame = (self.current_frame + 1) % len(self.idle_frames[self.current_direction])
                #self.image = self.idle_frames[self.current_direction][self.current_frame] #DO: Update the player's image to the second frame of the current direction's animation
    

    #DO: Update function to be called every frame
    def update(self, dt, player_rect): 
        self.movement(player_rect, dt) #WB: Updates the enemy's movements
        self.enemy_animations(dt) #WB: Calls the animation method
        
        #WB: Fire a projectile from the shooting enemy
    #def enemy_projectile(enemy_type, self, velocity, direction, projectile_type, damage_value):
        #angle = math.atan2(direction.y, direction.x) #WB: Turns direction vectors into angles
        #if enemy_type == "shooting":
            
        #projectile = Projectile(self.rect.centerx, self.rect.centery, velocity, angle, projectile_type, id(self), damage_value)
        #WB: Add projectile to the same group as enemy 
        #for group in self.groups():
            #group.add(projectile)
        #return projectile


            


        

            

        
               


        

class Camera(pygame.sprite.Group):
    def __init__(self,background):
        super().__init__()
        self.offset = pygame.math.Vector2() #DO: we must offset the surroundings by the -vector of our player's movement
        self.background = background
        self.floor_rect = self.background.get_rect(topleft = (0,0))
    def custom_draw(self,width,height,Player,all_sprites,screen): 
        '''
        DO:
        width - the width of the screen
        height - the height of the screen
        Player - our player that will be followed by the camera
        all_sprites - the group of sprites containing everything (in app class)
        screen - the actual screen variable (located in app)
        '''
        self.offset.x = Player.rect.centerx - width // 2
        self.offset.y = Player.rect.centery - height // 2
        
        #DO: drawing map
        floor_offset_pos = self.floor_rect.topleft - self.offset
        screen.fill((0,0,0))
        screen.blit(self.background, floor_offset_pos)

        for sprite in all_sprites:
            offset_pos = sprite.rect.topleft - self.offset
            screen.blit(sprite.image,offset_pos)
        



class App(): #DO: Define the main application class
    
    def __init__(self): #DO: Initialize the application
        self._running = True #DO: Set running equal to true for while loop in game logic
        self.screen = None #DO: Placeholder for screen object
        self.clock = pygame.time.Clock() #DO: Create a clock object to manage frame rate
        self.width = 1109
        self.height = 624
        self.size = self.width, self.height  #initalize screen size
        self.player = None #DO: Placeholder for player object
        self.all_sprites = pygame.sprite.Group() #DO: Create a sprite group to manage all sprites in the game
        self.enemies = pygame.sprite.Group() #WB: Create a enemies group to manage all enemies in the game
        
        self.dt = 0 #DO: Define delta time variable
        self.camera = None #DO: placeholder for camera variable
        self.dt = 0. #DO: Define delta time variable
        #DO: Placeholders for the map variables we need, these variabels (pytmx.load_pygame('...')  must be initalized after the screen)
        self.tmx_data = None
        self.tile_width = None
        self.tile_height = None 
        self.background = None #DO: Surface for background placeholder
        #DO: Wall variables 
        self.walls = pygame.sprite.Group() #DO: initalizes wall sprites
        self.collision_rects = []


    def on_init(self): #DO: Calls pygame.init()
        pygame.init()
        self.screen = pygame.display.set_mode(self.size, pygame.HWSURFACE | pygame.DOUBLEBUF) #DO: creates display
        self._running = True #DO:Set running equal to true
        #DO: map loading
        self.tmx_data = pytmx.load_pygame("Undead_land.tmx")
        self.tile_width = self.tmx_data.tilewidth
        self.tile_height = self.tmx_data.tileheight
        #DO: Create background surface and camera
        self.background = self.create_background_surface()
        self.camera = Camera(self.background)
        #DO: Create player object at center of surface(map)
        self.player = Player(self.tmx_data.width *self.tile_width // 2, self.tmx_data.height * self.tile_width // 2) #DO: initalize player
        player_positionx = self.player.rect.centerx 
        player_positiony = self.player.rect.centery 
        self.all_sprites.add(self.player) #DO: Add player to the all_sprites group
        enemy_1 = Enemy (player_positionx +1000, player_positiony, "standard") #WB: Add standard enemy and make it start 5 pixels to the right of player
        enemy_2 = Enemy (player_positionx, player_positiony + 2000, "moderate") #WB: Add moderate enemy and make it start 200 pixels higher than the player
        enemy_3 = Enemy (player_positionx - 4000, player_positiony - 3000, "strong") #WB: Add strong enemy and make it start 400 pixels to the left of the player and 300 pixels lower
        self.all_sprites.add(enemy_1, enemy_2, enemy_3) #WB: Add enemy to the all_sprites group
        self.enemies.add(enemy_1, enemy_2,enemy_3) #WB: Add player to the enemy group
        #DO: Walls
        self.load_walls() #DO: calls the load_walls function to load the layer of walls from the tmx file
        return True
 
    def on_event(self, event): #DO: Handle events
        if event.type == pygame.QUIT: #DO: if the user clicks the close button ends program
            self._running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_e:
                # FS: Fires projectile in front of player
                direction = self.player.current_direction
                # FS: Angle: right = 0, left = pi (turns out it uses radians huh)
                angle = 0 + random.random() - random.random() if direction == 'right' else math.pi + random.random() - random.random() #FS: Adjustable angle, some bullets can be random spread maybe??
                velocity = 500 #FS: Adjustable velocity
                projectile_type = 'plasma' # FS: probably will switch these values over to IDs later on
                damage_value = 10
                self.player.player_projectile(velocity, angle, projectile_type, damage_value)
            if event.key == pygame.K_p:
                # FS: Fires projectile in front of player
                direction = self.player.current_direction
                # FS: Angle: right = 0, left = pi
                angle = 0 if direction == 'right' else math.pi
                velocity = 1000 # FS: adjustable velocity
                projectile_type = 'laser' # FS: probably will switch these values over to IDs later on
                damage_value = 10
                self.player.player_projectile(velocity, angle, projectile_type,damage_value)
            if event.key == pygame.K_l:
                # FS: Let's try a shotgun! Fires 3 projectiles in a spread
                direction = self.player.current_direction
                # FS: Angle: right = 0, left = pi (turns out it uses radians huh)
                velocity = 500 #FS: Adjustable velocity
                projectile_type = 'plasma' # FS: probably will switch these values over to IDs later on
                damage_value = 10
                triplet_angles = [-math.pi/6,0,math.pi/6] if direction == 'right' else [math.pi + math.pi/6, math.pi, math.pi - math.pi/6]
                for angle in triplet_angles:
                    self.player.player_projectile(velocity, angle, projectile_type, damage_value)
                #FS: Some current issues, angles aren't equally spread and I don't know why yet.
                #DO: recall that when going around a circle to go beyond pi into Q3 of a cartesian plane you must add pi not subtract
                #DO: swapped ur signs in the "right" logic and it is now even.

                #FS: ALL OF THIS IS TEST CODE, IGNORE
                '''    
                circle8 = [1,2,3,4,5,6,7,8]
                thingythingy = math.pi/8
                for entry in circle8:
                    self.player.projectile_anywhere(200,200,500,entry*thingythingy,projectile_type,damage_value)
                '''
                #FS: END OF TEST CODE, IGNORE
    
    def on_loop(self): #DO: Main loop logic
        
        self.player.update(self.dt,self.collision_rects) #DO: Player logic that makes walls work, likely will also later work with enemy collisions
        for sprite in self.all_sprites:
            if isinstance(sprite, Projectile): #DO: parses all sprites in all_sprites and runs the regular code for that sprite if its a projectile.
                sprite.update(self.dt)
        for enemy in self.enemies:   
            enemy.update(self.dt, self.player.rect) #WB: Makes the enemy chase the player
        
        #Checks for player-enemy collisions
        for enemy in self.enemies:
                if isinstance (enemy, Enemy): #WB: Handles the case where the enemy hits the player
                    if enemy.rect.colliderect(self.player.rect): 
                        self.player.health -= enemy.damage #WB: When the player is hit by an enemy it loses health points
                        print("Player hit!")
                    
                    #WB: Checks if player is dead
                    if self.player.health <= 0: 
                        self.player.kill()
                        print("Player killed!")


                        
        #Checks for projectile-enemy collisions
        for enemy in self.enemies:
            for projectile in self.all_sprites:
                if isinstance(projectile, Projectile): #WB: Handles the case where the enemy is hit by a projectile
                    if enemy.rect.colliderect(projectile.rect):
                        enemy.health -= projectile.damage_value #WB: When the enemy is hit by a projectile, it loses health points
                        print(f"Enemy hit! Health: {enemy.health}")  

                    #WB: Checks if enemy is dead
                    if enemy.health <= 0:
                        enemy.kill()  #WB: Removes enemy from game
                        print("Enemy defeated!")
        



    def on_render(self): #DO: Render the display
        #DO: likely not needed anymore self.screen.fill((50,50,100)) #DO: reset the screen to black
        #self.draw_map(self.tmx_data, self.screen,self.tile_width,self.tile_height)
        #self.all_sprites.draw(self.screen) #DO: Draw all sprites in the all_sprites group to the screen
        self.camera.custom_draw(self.width, self.height, self.player, self.all_sprites, self.screen)
        pygame.display.flip() #DO: Update the full display surface to the screen

    

    def on_cleanup(self): #DO: cleanup resources
        pygame.quit() #DO: quits pygame
        exit() #DO: kills program no matter what
    

    def create_background_surface(self):
        #DO: determines size of world from tmx file
        map_width = self.tmx_data.width *self.tile_width
        map_height = self.tmx_data.height *self.tile_height
        #DO: creating a surface with the approriate dimensions of the world
        out = pygame.Surface((map_width, map_height))
        #DO:Call Draw map to draw on surface
        #DO: neededd if the background is black or smth at some area out.fill((50,50,100))
        self.draw_map(self.tmx_data,out,self.tile_width,self.tile_height)
        return out
    def load_walls(self):
        #DO: loads objects from tilemap for collisions
        #DO:try catch time
        try:
            walls_layer = None #DO: Initalize wall output
            for layer in self.tmx_data.layers: #DO: parses layers in the file
                if layer.name == 'Walls': #DO: if the Walls file is found it makes this layer our "layer" variable
                    walls_layer = layer
                    break
            if hasattr(walls_layer, 'data'):#DO: is there anything in this layer
                for x, y, gid in walls_layer: #DO: creates rects for collision for each wall sprite
                    if gid != 0: #DO: gid = 0 means empty
                        wall_rect = pygame.Rect(x*self.tile_width,y*self.tile_height,self.tile_width,self.tile_height)
                        self.collision_rects.append(wall_rect)
    
        except Exception as e:
            print(f'Error loading walls {e}')
            #DO: if the wall layer cannot be found catches it and prints out this line


    def draw_map(self, tmx_data, surface, tile_width, tile_height): #DO: draws a map based on given parameters using a desired map file  (as seen in the init)
        #DO: surface or screen both should work
        for layer in tmx_data.visible_layers: #DO: For each layer in our layered map
            if isinstance(layer, pytmx.TiledTileLayer):
                for x, y, gid in layer: 
                    tile = tmx_data.get_tile_image_by_gid(gid)
                    if tile: #DO: if it is a tile it blits the tile on screen
                        surface.blit(tile, (x * tile_width, y * tile_height)) 

    def on_execute(self): #DO: Execute the application
        if not self.on_init(): #DO:initalize the application
            self._running = False
 
        while self._running: #DO: game loop in which events, loop logic, then rendering occurs
            self.dt = self.clock.tick(144) / 1000.0 #DO: Calculate delta time in seconds
            for event in pygame.event.get(): #DO: Event handling loop
                self.on_event(event)
            self.on_loop() #DO: main loop logic
            self.on_render() #DO: render the display
        self.on_cleanup() #DO: cleanup prior to quitting
if (__name__ == "__main__") : #DO: Run the application
    the_app = App()
    the_app.on_execute()